/**
 * Create a state.
 *
 * @param {Options} options
 *   User configuration.
 * @returns {State}
 *   State.
 */
export function createState(options: Options): State
export type Root = import('hast').Root
export type Content = import('hast').Content
export type Element = import('hast').Element
export type MdastRoot = import('mdast').Root
export type MdastContent = import('mdast').Content
export type MdastBlockContent = import('mdast').BlockContent
export type MdastDefinitionContent = import('mdast').DefinitionContent
export type Options = import('./types.js').Options
export type Handle = import('./types.js').Handle
export type NodeHandle = import('./types.js').NodeHandle
export type Node = Root | Content
export type Parent = Extract<Node, import('unist').Parent>
export type MdastParent = Extract<MdastNode, import('unist').Parent>
export type MdastNode = MdastRoot | MdastContent
export type MdastFlowContent = MdastBlockContent | MdastDefinitionContent
/**
 * Info passed around about the current state.
 */
export type State = {
  /**
   * Copy a node’s positional info.
   */
  patch: Patch
  /**
   * Transform a hast node to mdast.
   */
  one: One
  /**
   * Transform the children of a hast parent to mdast.
   */
  all: All
  /**
   * Transform a list of mdast nodes to flow.
   */
  toFlow: ToFlow
  /**
   * Turn arbitrary content into a list of a particular node type.
   *
   * This is useful for example for lists, which must have list items as
   * content.
   * in this example, when non-items are found, they will be queued, and
   * inserted into an adjacent item.
   * When no actual items exist, one will be made with `build`.
   */
  toSpecificContent: <
    ChildType extends MdastNode,
    ParentType extends MdastParent & {
      children: ChildType[]
    }
  >(
    nodes: Array<MdastContent>,
    build: () => ParentType
  ) => ParentType[]
  /**
   * Resolve a URL relative to a base.
   */
  resolve: Resolve
  /**
   * User configuration.
   */
  options: Options
  /**
   * Elements by their `id`.
   */
  elementById: Map<string, Element>
  /**
   * Applied element handlers.
   */
  handlers: Record<string, Handle>
  /**
   * Applied node handlers.
   */
  nodeHandlers: Record<string, NodeHandle>
  /**
   * Whether a `<base>` element was seen.
   */
  baseFound: boolean
  /**
   * `href` of `<base>`, if any.
   */
  frozenBaseUrl: string | undefined
  /**
   * Whether we’re in a table.
   */
  inTable: boolean
  /**
   * Non-negative finite integer representing how deep we’re in `<q>`s.
   */
  qNesting: number
}
/**
 * Copy a node’s positional info.
 */
export type Patch = (from: Node, to: MdastNode) => void
/**
 * Transform the children of a hast parent to mdast.
 */
export type All = (parent: Parent) => Array<MdastContent>
/**
 * Transform a list of mdast nodes to flow.
 */
export type ToFlow = (nodes: Array<MdastContent>) => Array<MdastFlowContent>
/**
 * Transform a hast node to mdast.
 */
export type One = (
  node: Node,
  parent: Parent | undefined
) => MdastNode | Array<MdastNode> | void
/**
 * Resolve a URL relative to a base.
 */
export type Resolve = (url: string | null | undefined) => string
