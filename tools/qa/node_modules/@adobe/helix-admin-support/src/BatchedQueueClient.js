/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
import {
  DeleteMessageBatchCommand,
  ReceiveMessageCommand,
  SendMessageBatchCommand,
  SQSClient,
} from '@aws-sdk/client-sqs';
import {
  S3Client,
  PutObjectCommand,
} from '@aws-sdk/client-s3';

const MAX_BATCH_SIZE = 256 * 1024;

const DEFAULT_BUCKET_ID = 'helix-content-bus';

const DEFAULT_MESSAGE_SWAP_PREFIX = 'default/sqs-swap';

export function hsize(bytes, decimals = 2) {
  if (bytes === 0) {
    return '0 bytes';
  }
  const k = 1024;
  const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  // eslint-disable-next-line no-restricted-properties
  return `${parseFloat((bytes / k ** i).toFixed(decimals))} ${sizes[i]}`;
}

/**
 * @typedef BatchedQueueClientOpts
 * @property {Console} [log=Console] Console like logger
 * @property {number} [maxSqsPollTime=20] Time to poll for messages
 * @property {string} inQueue Name of the receiving queue
 * @property {string} outQueue Name of the output queue
 * @property {object} s3ClientOpts S3 client options
 * @property {object} sqsClientOpts SQS client options
 * @property {Array<string>} headerKeys Name of the properties that common to all message properties
 * @property {string} swapBucket Name of the bucket used for swap space
 * @property {string} swapPrefix Prefix for the swap objects
 */

/**
 * Creates a new BatchedQueueClient. It allows to read and write from a SQS queue in batches,
 * supporting larger batch sizes than the default of 10. If a message gets too big for SQS it is
 * automatically swapped out to S3.
 */
export class BatchedQueueClient {
  static createMessage(owner, repo, data) {
    return {
      MessageBody: JSON.stringify({
        owner,
        repo,
        ...data,
      }),
      MessageAttributes: {
        owner: {
          DataType: 'String',
          StringValue: owner,
        },
        repo: {
          DataType: 'String',
          StringValue: repo,
        },
      },
    };
  }

  /**
   * Creates a new client
   * @param {BatchedQueueClientOpts} opts Options
   */
  constructor(opts) {
    this.sqs = new SQSClient(opts.sqsClientOpts);
    this.s3 = new S3Client(opts.s3ClientOpts);
    this.log = opts.log || console;
    this.maxSqsPollTime = opts.maxSqsPollTime || 20;
    this.inQueue = opts.inQueue;
    this.outQueue = opts.outQueue;
    this.swapPrefix = opts.swapPrefix || DEFAULT_MESSAGE_SWAP_PREFIX;
    this.swapBucket = opts.swapBucket || DEFAULT_BUCKET_ID;
  }

  /**
   * Extended version of the SQS ReceiveMessageCommand, that supports long polling for wait times
   * over 20s and max messages for over 10. It will continue at least `minTime` seconds to poll
   * until `maxMessages` are received. It will continue polling if at least 1 message was
   * received until the `maxTime` is reached.
   *
   * @param {number} [minTime = 10]
   * @param {number} [maxTime = 30]
   * @param {number} [maxMessages = 1000]
   * @returns {Promise<Message[]>}
   */
  async receive(minTime = 10, maxTime = 30, maxMessages = 1000) {
    const { log, sqs } = this;
    const messages = [];
    const endMinTime = Date.now() + minTime * 1000;
    const endMaxTime = Date.now() + maxTime * 1000;

    log.info(`starting polling loop on ${this.inQueue} during ${minTime}s and ${maxMessages} max message.`);

    let maybeMore = false;
    while (messages.length < maxMessages) {
      let timeRemaining = Math.round((endMinTime - Date.now()) / 1000);
      let currentMaxTime = minTime;
      if (timeRemaining <= 0 && maybeMore) {
        timeRemaining = Math.round((endMaxTime - Date.now()) / 1000);
        currentMaxTime = maxTime;
      }
      if (timeRemaining <= 0) {
        break;
      }
      const waitTime = Math.min(this.maxSqsPollTime, timeRemaining);
      const maxMgs = Math.min(10, maxMessages - messages.length);

      log.debug(`polling ${this.inQueue} for ${waitTime}s (${currentMaxTime - timeRemaining}s/${currentMaxTime}s (max ${maxMgs} msgs)...`);
      // eslint-disable-next-line no-await-in-loop
      const result = await sqs.send(new ReceiveMessageCommand({
        MaxNumberOfMessages: maxMgs,
        WaitTimeSeconds: waitTime,
        QueueUrl: this.inQueue,
        MessageAttributeNames: ['All'],
      }));
      const { Messages = [] } = result;
      messages.push(...Messages);
      maybeMore = Messages.length > 0;
      log.debug(`last poll received ${Messages.length} messages from queue (${messages.length}).`);
    }
    log.info(`received ${messages.length} messages from queue ${this.inQueue}`);
    return messages;
  }

  /**
   * Delete messages from the inQueue
   * @param {Message[]} messages
   * @returns {Promise<void>}
   */
  async delete(messages) {
    const { log, sqs } = this;
    const total = messages.length;
    let deleted = 0;
    while (messages.length) {
      const batch = messages.splice(0, 10);
      log.info(`deleting ${batch.length} messages from ${this.inQueue}...`);
      // eslint-disable-next-line no-await-in-loop
      const result = await sqs.send(new DeleteMessageBatchCommand({
        QueueUrl: this.inQueue,
        Entries: batch.map((msg, idx) => ({
          Id: idx,
          ReceiptHandle: msg.ReceiptHandle,
        })),
      }));
      const { Successful = [], Failed = [] } = result;
      if (Failed.length) {
        log.warn(`failed to delete ${Failed.length} from queue.`);
      }
      deleted += Successful.length;
      log.info(`deleted. ${deleted}/${total} from ${this.inQueue} done.`);
    }
  }

  /**
   * Serializes a message to the swap storage.
   * @param {Message} msg
   * @returns {Promise<Message>} a new message containing the information about the swap location.
   */
  async serialize(msg) {
    const { log } = this;
    const oldBody = JSON.parse(msg.MessageBody);
    const { owner, repo, key } = oldBody;
    const swapKey = `${this.swapPrefix}/${key}-${Date.now()}.json`;
    await this.s3.send(new PutObjectCommand({
      Body: msg.MessageBody,
      Bucket: this.swapBucket,
      ContentType: 'application/json',
      Key: swapKey,
    }));
    const swapS3Url = `s3://${this.swapBucket}/${swapKey}`;
    log.info(`[${key}]message serialized to ${swapS3Url}`);
    const newBody = {
      owner,
      repo,
      key,
      swapS3Url,
    };
    return {
      MessageGroupId: msg.MessageGroupId,
      MessageDeduplicationId: msg.MessageDeduplicationId,
      MessageBody: JSON.stringify(newBody),
    };
  }

  /**
   * Sends a batch of messages to the `outQueue`.
   * @param {Message[]} messages
   * @returns {Promise<void>}
   */
  async send(messages) {
    const { log, sqs } = this;
    const total = messages.length;
    let sent = 0;
    let batchSize = 0;
    let batch = [];
    let send = false;
    while (messages.length) {
      let msg = messages.shift();
      let size = JSON.stringify(msg).length;
      if (batchSize + size < MAX_BATCH_SIZE) {
        batch.push(msg);
        batchSize += size;
      } else if (batch.length === 0) {
        // message doesn't fit in any batch - serializing to s3
        log.info(`[${msg.MessageGroupId}] message to big: ${hsize(size)}. serializing to s3...`);
        // eslint-disable-next-line no-await-in-loop
        msg = await this.serialize(msg);
        size = JSON.stringify(msg).length;
        batch.push(msg);
        batchSize += size;
      } else {
        // put message back
        log.info(`[${msg.MessageGroupId}] message to big: ${hsize(size)}. sending current batch...`);
        messages.unshift(msg);
        send = true;
      }

      // if the size limit or the num-messages limit is reached, or of we are done, send the batch
      if (send || batch.length === 10 || messages.length === 0) {
        log.info(`sending ${batch.length} messages to ${this.outQueue}...`);
        // eslint-disable-next-line no-await-in-loop
        const result = await sqs.send(new SendMessageBatchCommand({
          QueueUrl: this.outQueue,
          Entries: batch.map((data, idx) => ({
            Id: idx,
            ...data,
          })),
        }));
        const { Successful = [], Failed = [] } = result;
        if (Failed.length) {
          log.warn(`failed to send ${Failed.length} to queue.`);
        }
        sent += Successful.length;
        log.info(`sent. ${sent}/${total} (${hsize(batchSize)} to ${this.outQueue} done.`);
        batch = [];
        batchSize = 0;
        send = false;
      }
    }
  }

  /**
   * Closes this client and destroys the underlying datastructures
   */
  close() {
    this.sqs.destroy();
    this.s3.destroy();
  }
}
